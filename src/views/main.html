<!DOCTYPE html>
<html>

<head>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.13.0/moment.min.js"></script>
    <script src="https://www.chartjs.org/dist/2.8.0/Chart.min.js"></script>
    <script src="https://www.chartjs.org/samples/latest/utils.js"></script>
    <script src="js/amazon-cognito-identity.min.js"></script>
    <script src="js/config.js"></script>
    <link href="https://fonts.googleapis.com/css?family=Roboto+Mono:400,700i&display=swap" rel="stylesheet">
    <link rel="stylesheet" type="text/css" href="main.css">
</head>

<body>
    <img class="logo_groomit" src="groomit_logo.jpg" alt="Groomit logo" onclick="window.location.href='login.html'">

    <div class="info">9room Server <detail class="detail">무선 방사능 및 온습도 측정시스템</detail></div>

    <!-- select device -->
    <div class="devices">
        <select id="devices" onchange="changeGraph(this.value)">
            <option value=''>기기 선택 list box</option>
        </select>

        <button type="button" onclick="signOut()">Sign out</button>
        <button type="button" onclick="window.location.href='profile.html' ;">Profile</button>
    </div>

    <!-- buttons for logout or see profile -->
    <div class="container">
        <div id="graph">
            <canvas id="canvasG"></canvas>
        </div>
        <div id="graph">
            <canvas id="canvasTH"></canvas>
        </div>
    </div>

    <!-- select term -->
    <div class="date">
        조회기간 선택:
        <input type="date" id="start_date" onchange="chanegMinEndD()"> ~
        <input type="date" id="end_date" onchange="chanegMaxStartD()">
        <button id="changeDate" type="submit" onclick="changeDate()">select</button>
    </div>
    <button type="submit" onclick="json2csv()">Download!</button>

    <script>
            var uuid;
            var email;
            var datas;
            var c_val = 'gth';

            var data = {
                UserPoolId: _config.cognito.userPoolId,
                ClientId: _config.cognito.clientId
            };
            var userPool = new AmazonCognitoIdentity.CognitoUserPool(data);
            var cognitoUser = userPool.getCurrentUser();

            if (cognitoUser != null) {
                cognitoUser.getSession(function(err, session) {
                    if (err) {
                        alert(err);
                        return;
                    }
                    console.log('session validity: ' + session.isValid());
                    //Set the profile info
                    cognitoUser.getUserAttributes(function(err, result) {
                        if (err) {
                            console.log(err);
                            return;
                        }
                        console.log(result);
                        email = result[3].getValue();
                        console.log(email)
                        getGraph();
                    });
                });
            }

            function signOut() {
                if (cognitoUser != null) {
                    cognitoUser.signOut();
                    window.location.href = 'login.html';
                }
            }

            function getGraph() {
                var xhr = new XMLHttpRequest();
                xhr.open('GET', '/main/mainUuid?email=' + email); // 메소드와 주소 설정
                xhr.onreadystatechange = function() { // 요청에 대한 콜백
                    if (xhr.readyState === xhr.DONE) { // 요청이 완료되면
                        if (xhr.status === 200 || xhr.status === 201) {
                            // 메인 uuid설정란 db에 만들기?
                            var uuids = JSON.parse(xhr.responseText);
                            console.log(uuids.length)
                            if (uuids.length == 0) {
                                uuid = null;
                            } else {
                                uuid = uuids[0].deviceNum;
                                addSelection(uuids);
                                getGraphData(null, null);
                                getDateLimit();
                            }
                        } else {
                            console.error(xhr.responseText);
                        }
                    }
                };
                xhr.send();
            }

            function getGraphData(startD, endD) {
                var xhr = new XMLHttpRequest();
                xhr.open('GET', '/main/graphInfo?u=' + uuid + '&type=' + c_val + '&startD=' + startD + '&endD=' + endD); // 메소드와 주소 설정
                xhr.onreadystatechange = function() { // 요청에 대한 콜백
                    if (xhr.readyState === xhr.DONE) { // 요청이 완료되면
                        if (xhr.status === 200 || xhr.status === 201) {
                            // console.log(JSON.parse(xhr.responseText));
                            // console.log(startD)
                            datas = JSON.parse(xhr.responseText);
                            sortdata();
                        } else {
                            console.error(xhr.responseText);
                        }
                    }
                };
                xhr.send();
            }

            function sortdata() {
                var labels = [];
                var g_data = [];
                var t_data = [];
                var h_data = [];

                for (key in datas) {
                    // console.log(datas[key].type)
                    type = datas[key].type;
                    CDate = new Date(datas[key].time);
                    value = datas[key].val;

                    if (type == 'g') {
                        g_data.push({
                            x: CDate,
                            y: value
                        })
                    }
                    if (type == 't') {
                        t_data.push({
                            x: CDate,
                            y: value
                        })
                    }
                    if (type == 'h') {
                        h_data.push({
                            x: CDate,
                            y: value
                        })
                    }
                    if (!labels.includes(new Date(datas[key].time))) {
                        labels.push(CDate)
                    }
                }
                // console.log(g_data)
                drawGraph(c_val, labels, g_data, t_data, h_data);
            }

            function drawGraph(c_val, labels, g_data, t_data, h_data) {
                // console.log(g_data)
                const DATASET_G = {
                    label: 'geiger count',
                    data: g_data,
                    backgroundColor: window.chartColors.red,
                    borderColor: window.chartColors.red,
                    type: 'line',
                    pointRadius: 0,
                    fill: false,
                    lineTension: 0,
                    borderWidth: 1,
                }

                const DATASET_T = {
                    label: 'temperature',
                    data: t_data,
                    backgroundColor: window.chartColors.blue,
                    borderColor: window.chartColors.blue,
                    type: 'line',
                    pointRadius: 0,
                    fill: false,
                    lineTension: 0,
                    borderWidth: 1,
                }

                const DATASET_H = {
                    label: 'humidity',
                    data: h_data,
                    backgroundColor: window.chartColors.orange,
                    borderColor: window.chartColors.orange,
                    type: 'line',
                    pointRadius: 0,
                    fill: false,
                    lineTension: 0,
                    borderWidth: 1,
                }

                let dataset_arr_g = [];
                let dataset_arr_th = []

                if (c_val.includes("g")) {
                    dataset_arr_g.push(DATASET_G);
                    getGgraph(labels, dataset_arr_g);
                }
                if (c_val.includes("t") || c_val.includes("h")) {
                    if (c_val.includes("t")) {
                        dataset_arr_th.push(DATASET_T);
                    }
                    if (c_val.includes("h")) {
                        dataset_arr_th.push(DATASET_H);
                    }
                    getTHgraph(labels, dataset_arr_th);
                }
            }

            function getGgraph(labels, dataset_arr_g) {
                var config_g = {
                    type: 'line',
                    data: {
                        labels: labels,
                        datasets: dataset_arr_g
                    },
                    options: {
                        responsive: true,
                        title: {
                            display: true,
                            text: 'G_graph of device: ' + uuid
                        },
                        scales: {
                            xAxes: [{
                                type: 'time',
                                // time: {
                                // unit: 'second',
                                // displayFormats: {
                                //     month: 'MMM YYYY'
                                // }
                                // },
                                distribution: 'series',
                                display: true,
                            }],
                            yAxes: [{
                                display: true,
                                type: 'linear',
                            }]
                        }
                    }
                };

                var ctx_g = document.getElementById('canvasG').getContext('2d');
                window.myLine = new Chart(ctx_g, config_g);
                window.myLine.update();
            }

            function getTHgraph(labels, dataset_arr_th) {
                var config_th = {
                    type: 'line',
                    data: {
                        labels: labels,
                        datasets: dataset_arr_th
                    },
                    options: {
                        responsive: true,
                        title: {
                            display: true,
                            text: 'T&H_raph of device: ' + uuid
                        },
                        scales: {
                            xAxes: [{
                                type: "time",
                                time: {
                                    parser: "MM/DD/YYYY HH:mm",
                                    // round: 'day'
                                    tooltipFormat: "ll HH:mm"
                                },
                                // scaleLabel: {
                                //     display: true,
                                //     labelString: "Date"
                                // },
                                ticks: {
                                    maxRotation: 0
                                },
                                distribution: 'series',
                            }],
                            yAxes: [{
                                type: 'linear',
                                // scaleLabel: {
                                //     display: true,
                                //     labelString: "value"
                                // }
                            }]
                        },
                        pan: {
                            enabled: true,
                            mode: 'x' // is panning about the y axis neccessary for bar charts?
                        },
                        zoom: {
                            enabled: true,
                            mode: "x",
                            sensitivity: 1
                        },
                        // zoom: {
                        //     enabled: true,
                        //     drag: false,

                        //     limits: {
                        //         max: 10,
                        //         min: 0.5
                        //     }
                        // }
                    }
                };

                var ctx_th = document.getElementById('canvasTH').getContext('2d');
                window.myLine = new Chart(ctx_th, config_th);
                window.myLine.update();
            }

            function addSelection(uuids) {
                var selection = document.getElementById("devices");
                console.log(selection.length)
                if (selection.length == 1) {
                    for (i in uuids) {
                        var option = document.createElement("option");

                        option.text = uuids[i].deviceNum;
                        option.value = uuids[i].deviceNum;
                        selection.add(option)
                        console.log(uuids[i])
                    }
                } else if (uuids.length > selection.length) {
                    // TODO:: 추가시 어떻게 할지 확인
                }
            }

            function changeGraph(device) {
                uuid = device;
                getGraphData(null, null)
            }

            function getDateLimit() {
                var xhr = new XMLHttpRequest();

                xhr.open('GET', '/main/dateLimit?u=' + uuid); // 메소드와 주소 설정
                xhr.onreadystatechange = function() { // 요청에 대한 콜백
                    if (xhr.readyState === xhr.DONE) { // 요청이 완료되면
                        if (xhr.status === 200 || xhr.status === 201) {
                            var mintime = "MIN(time)"
                            console.log(JSON.parse(xhr.responseText)[0]);
                            var date_limits = JSON.parse(xhr.responseText);

                            var min_date = (new Date(date_limits[0].mintime)).toISOString().substr(0, 10);
                            var max_date = new Date(date_limits[0].maxtime);

                            max_date.setDate(max_date.getDate() + 1);
                            max_date = max_date.toISOString().substr(0, 10);

                            document.getElementById("start_date").min = min_date;
                            document.getElementById("end_date").max = max_date;
                        } else {
                            console.error(xhr.responseText);
                        }
                    }
                };
                xhr.send();
            }

            function changeDate() {
                var startDate = document.getElementById("start_date");
                var endDate = new Date(document.getElementById("end_date").value);

                endDate.setDate(endDate.getDate() + 1);
                endDate = endDate.toISOString().substr(0, 10);

                if (startDate == '' || endDate == '') {
                    alert("Please enter the term to check");
                } else {
                    getGraphData(startDate, endDate)
                }
            }

            function chanegMinEndD(){
                var min_date = document.getElementById("start_date").value;
                document.getElementById("end_date").min = min_date;
            }

            function chanegMaxStartD(){
                var max_date = document.getElementById("end_date").value;
                document.getElementById("start_date").max = max_date;
            }

            function json2csv() {
                var array = typeof datas != 'object' ? JSON.parse(datas) : datas;

                var str = '';
                var line = '';

                var head = array[0];

                for (var index in array[0]) {
                    var value = index + "";
                    line += '"' + value.replace(/"/g, '""') + '",';
                }

                line = line.slice(0, -1);
                str += line + '\r\n';

                for (var i = 0; i < array.length; i++) {
                    var line = '';

                    for (var index in array[i]) {
                        var value = array[i][index] + "";
                        line += '"' + value.replace(/"/g, '""') + '",';
                    }

                    line = line.slice(0, -1);
                    str += line + '\r\n';
                }

                var hiddenElement = document.createElement('a');
                hiddenElement.href = 'data:text/csv;charset=utf-8,' + encodeURI(str);
                hiddenElement.target = '_blank';
                hiddenElement.download = uuid + '.csv';
                hiddenElement.click();
                // window.open("data:text/csv;charset=utf-8," + escape(str));
            }
        </script>
</body>

</html>